# ЛР10 — Структуры данных: Stack, Queue, Linked List и бенчмарки

## Теория
### Стек (Stack)

    Принцип: LIFO — Last In, First Out.

    Операции:
        push(x) — положить элемент сверху;
        pop() — снять верхний элемент;
        peek() — посмотреть верхний, не снимая.

    Типичные применения:
        история действий (undo/redo);
        обход графа/дерева в глубину (DFS);
        парсинг выражений, проверка скобок.

    Асимптотика (при реализации на массиве / списке):
        push — O(1) амортизированно;
        pop — O(1);
        peek — O(1);
        проверка пустоты — O(1).

    Сложность:
        Сложность структуры стека (stack) заключается в её ограниченном наборе операций 
        и принципе работы. Пользователь или программист может добавлять и удалять элементы 
        только с одного конца структуры — верхушки стека. Доступ к элементам, находящимся ниже 
        верхнего элемента, невозможен без предварительного удаления всех элементов, находящихся 
        выше них.

### Очередь (Queue)

    Принцип: FIFO — First In, First Out.

    Операции:
        enqueue(x) — добавить в конец;
        dequeue() — взять элемент из начала;
        peek() — посмотреть первый элемент, не удаляя.

    Типичные применения:
        обработка задач по очереди (job queue);
        обход графа/дерева в ширину (BFS);
        буферы (сетевые, файловые, очереди сообщений).

    В Python:
        обычный list плохо подходит для реализации очереди:
            удаление с начала pop(0) — это O(n) (все элементы сдвигаются);
        collections.deque даёт O(1) операции по краям:
            append / appendleft — O(1);
            pop / popleft — O(1).

    Асимптотика (на нормальной очереди):
        enqueue — O(1);
        dequeue — O(1);
        peek — O(1).

    Сложность:
        Сложность структуры очередь (queue) заключается в её ограниченном наборе операций 
        и принципе работы. Пользователь или программист может добавлять элементы только в конец очереди 
        и извлекать только из начала. Доступ к элементам, находящимся в середине очереди, невозможен 
        без предварительного удаления всех элементов, находящихся перед ними

### Односвязный список (Singly Linked List)

    Структура:
        состоит из узлов Node;
        каждый узел хранит:
            value — значение элемента;
            next — ссылку на следующий узел или None (если это последний).

    Основные идеи:
        элементы не хранятся подряд в памяти, как в массиве;
        каждый элемент знает только «следующего соседа».

    Плюсы:
        вставка/удаление в начало списка за O(1):
            если есть ссылка на голову (head), достаточно перенаправить одну ссылку;
        при удалении из середины не нужно сдвигать остальные элементы:
            достаточно обновить ссылки узлов;
        удобно использовать как базовый строительный блок для других структур (например, для очередей, стеков, хеш-таблиц с цепочками).

    Сложность и минусы:
        доступ по индексу i — O(n):
            чтобы добраться до позиции i, нужно пройти i шагов от головы;
        нет быстрого доступа к предыдущему элементу:
            чтобы удалить узел, нужно знать его предыдущий узел → часто нужен дополнительный проход.

    Типичные операции и их асимптотика:
        prepend (добавить в начало) — O(1);
        append:
            при наличии tail — O(1),
            без tail — O(n), т.к. требуется пройти до конца;
        поиск по значению — O(n).
